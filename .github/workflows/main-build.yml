name: User-data-ESO

on:
  push:
    branches:
      - main

  workflow_dispatch:


permissions:
  contents: read
  actions: read
  pull-requests: write
  security-events: write


env:
    AWS_ACCESS_KEY_ID : ${{ secrets.AWS_ACCESS_KEY_ID}}
    AWS_SECRET_ACCESS_KEY : ${{ secrets.AWS_SECRET_ACCESS_KEY}}
    AWS_REGION: ${{ secrets.AWS_REGION }}
    ECR_REPO: ${{ secrets.ECR_REPO }}
    AWS_ACCESS_KEY_ID_ESO : ${{ secrets.AWS_ACCESS_KEY_ID_ESO}}
    AWS_SECRET_ACCESS_KEY_ESO : ${{ secrets.AWS_SECRET_ACCESS_KEY_ESO}}

# env:
#   AWS_REGION: us-east-1
#   POSTGRES_USER: postgres
#   POSTGRES_PASSWORD: postgres
#   POSTGRES_DB: testdb

jobs:

  SAST:
    name: Analyze Code with CodeQL
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: python  # Update with your languages

    - name: Autobuild
      uses: github/codeql-action/autobuild@v3

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3


  app:
    name: Build or Use Existing Image & Deploy
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


      - name: Check EKS Cluster Status with AWS CLI
        run: |
            CLUSTER_NAME="custom-eks" #Replace with your cluster name
            CLUSTER_STATUS=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.status' --output text)
            echo "EKS Cluster Status: $CLUSTER_STATUS"
            if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
              echo "EKS cluster is not active!"
              exit 1
            fi
          
      - name: Login to Amazon ECR
        run: |
          aws ecr-public get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ env.ECR_REPO }} 

          
      # - name: Detect App Code Changes
      #   id: detect
      #   run: |
      #     CHANGED=false
      #     if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.triggered_by_infra }}" == "true" ]]; then
      #       CHANGED=false
      #     else
      #       git fetch origin ${{ github.base_ref || 'main' }}
      #       CHANGED=$(git diff --name-only origin/${{ github.base_ref || 'main' }}...HEAD | grep '^backend/' || true)
      #     fi
      #     echo "app_changed=$CHANGED" >> $GITHUB_OUTPUT


      - name: Start Falco
        uses: falcosecurity/falco-actions/start@main
        with:
          mode: live
          falco-version: '0.39.0'
          verbose: true


      - name: Build & Push New Image
        # if: steps.detect.outputs.app_changed
        run: |
          IMAGE_TAG=latest
          #IMAGE_TAG=build-${{ github.sha }}
          docker build -t ${{ env.ECR_REPO }}:$IMAGE_TAG .
          docker push ${{ env.ECR_REPO }}:$IMAGE_TAG
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master # Use the official Trivy action
        with:
            image-ref: '${{ env.ECR_REPO }}:latest' # Specify the image to scan
            format: 'sarif' # Output format (e.g., table, json, sarif) (Static Analysis Results Interchange Format) 
            output: 'trivy-results.sarif' # Output file name
            exit-code: '1' # Fail the workflow if vulnerabilities are found
            ignore-unfixed: true # Ignore unfixed vulnerabilities
            #severity: 'CRITICAL,HIGH' # Scan for specified severity levels
        continue-on-error: true # Continue even if vulnerabilities are found
            # You can also add other options like:
            # cache-dir: '/tmp/.trivycache' # Specify cache directory
            #sarif-file: 'trivy-results.sarif' # Output SARIF file for GitHub Security tab
  
      #   # Optional: Upload scan results to GitHub Security tab (if using SARIF format)
      # - name: Upload Trivy scan results to GitHub Security tab
      #   if: always() && steps.trivy-scan.outputs.sarif-file != '' # Only run if SARIF file was generated
      #   uses: github/codeql-action/upload-sarif@v3
      #   with:
      #     sarif_file: 'trivy-results.sarif' # Path to your SARIF output file


      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Stop Falco
        uses: falcosecurity/falco-actions/stop@main
        with:
          verbose: true


      - name: Upload Falco capture
        uses: actions/upload-artifact@v4
        with:
          name: capture
          path: /tmp/falco-capture.json
          if-no-files-found: ignore

  
      - name: Analyze Falco Results 
        uses: falcosecurity/falco-actions/analyze@main
        continue-on-error: true

      - name: Update image in backend.yaml
        run: |
          sed -i "s|image: .*|image: ${{ env.ECR_REPO }}:latest|" k8s/backend.yaml
          echo "Updated image in k8s/backend.yaml to latest"

      - name: Update Kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name custom-eks
          kubectl get nodes
      
      - name: Install helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version

      - name: Add External Secrets Helm Repo
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm install external-secrets external-secrets/external-secrets -n external-secrets --create-namespace
          
      - name: Wait for External Secrets to be ready
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets -n external-secrets
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets-webhook -n external-secrets

      - name: Deploy to EKS
        run: |
          kubectl create ns myapp
          kubectl create secret generic awssm-secret  --from-literal=access-key=${{ secrets.AWS_ACCESS_KEY_ID_ESO }} --from-literal=secret-access-key=${{secrets.AWS_SECRET_ACCESS_KEY_ESO}} -n myapp
          kubectl apply -f k8s/secretstore.yaml
          kubectl apply -f k8s/externalsecret.yaml
          kubectl apply -f k8s/pg16-ESO.yaml
          kubectl apply -f k8s/pvc-eks.yaml
          kubectl apply -f k8s/backend.yaml
          #kubectl rollout restart deployment backend -n myapp
          kubectl rollout status deployment backend -n myapp
          kubectl get all -n myapp
          #kubectl set image deployment/backend backend-container=${{ env.ECR_REPO }}:$IMAGE_TAG -n myapp
          #kubectl rollout status deployment backend -n myapp 


      
      # - name: Test the Deployment 
      #   run: |
      #     # Wait for a few seconds to ensure the service is up
      #     sleep 15
      #     # Get the ClusterIP of the backend service
      #     CLUSTER_IP=$(kubectl get svc backend-service -n myapp -o jsonpath='{.spec.clusterIP}')
      #     echo "Cluster IP: $CLUSTER_IP"
      #     # Test the backend service endpoint
      #     RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$CLUSTER_IP:8008/health)
      #     if [ "$RESPONSE" -eq 200 ]; then
      #       echo "Backend service is healthy!"
      #     else
      #       echo "Backend service is not reachable. HTTP Status: $RESPONSE"
      #       exit 1
      #     fi

      # - name: Cleanup ECR    
      #   run: |
      #     # Keep only the latest 3 images, delete older ones
      #     aws ecr-public describe-images --repository-name backend --query 'imageDetails[?imageTags[0]!=`null`]|sort_by(@,&imagePushedAt)[].imageTags[0]' --output text | \
      #     awk 'NR>3' | \
      #     xargs -I {} aws ecr-public batch-delete-image --repository-name backend --image-ids imageTag={}
      #     echo "Old images are cleaned up from ECR."

      # List all images with non-null tags sorted by imagePushedAt (newest last)
      - name: Clean up old ECR images
        shell: bash
        run: |
          TAGS=$(aws ecr-public describe-images \
            --repository-name backend \
            --query 'imageDetails[?imageTags[0]!=`null`]|sort_by(@,&imagePushedAt)[].imageTags[0]' \
            --output text)
          read -a TAG_ARRAY <<< $TAGS
          if [ "${#TAG_ARRAY[@]}" -gt 3 ]; then
            DELETE_TAGS=( "${TAG_ARRAY[@]:0:${#TAG_ARRAY[@]}-3}" )
            for tag in "${DELETE_TAGS[@]}"; do
                echo "Deleting $tag"
                aws ecr-public batch-delete-image \
                  --repository-name backend \
                  --image-ids imageTag="$tag"
            done
          fi
          echo "Old images are cleaned up from ECR."
